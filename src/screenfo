#!/usr/bin/perl
our $APP     = 'screenfo';
our $VERSION = 0.23;
use strict;
use Data::Dumper;
use List::Util qw(shuffle);
use String::Utils qw(longest);
use Getopt::Long;
use Pod::Usage;

my $DEBUG = 0;

eval { require("$ENV{XDG_CONFIG_HOME}/screenfo/screenfo.conf"); };
if($@) {
  eval { require('/etc/screenfo.conf'); };
  if($@) {
    print STDERR "No configuration file found\n";
    exit(-1);
  }
}

# imported from configuration file
our($now_playing, $default_colorscheme, %colorschemes, $default_logo,
    $color_support);
our($opt_random_colors, $opt_shot) = undef;

get_color_support();

GetOptions(
  'ascii:s' => \$default_logo,
  'color:s' => \$default_colorscheme,
  'list'    => \&available_colorschemes,
  'norand'  => \$opt_random_colors,
  'shot'    => \$opt_shot,
  'help'    => sub { pod2usage(verbose => 1) and exit(0); },
  'version' => sub { printf("%s %s\n", $APP, $VERSION); exit(0); },
);

# FIXME -e /usr/share/... || ./ascii/.. || croak()
$default_logo = "/usr/share/screenfo/ascii/$default_logo";

sub get_color_support {
  chomp(my $colors = `tput colors`);
  if(!defined($colors)) {
    $colors = 256;
  }
  if($colors < 255) {
    $color_support = 16; # dont bother with terms not supporting color
    # mm, maintaince mayhem
    %colorschemes = (
    all        => [0..15],
    ansi       => [0..15],            # obviously the same thing here
    grey       => [0,8,7,15],         # black, bright black, white, bright white
    red        => [1,9],              # red, bright red
    green      => [2,10],             # green, bright green
    white      => [7,15],             # white, bright white
    blue       => [4,12],             # blue, bright blue
    pink       => [5,13],             # magenta, bright magenta
    yellow     => [3,11],             # yellow, bright yellow (' brown ')
    fire       => [1,11,9,3],         # red, bright yellow, bright red, yellow
    pinkgrey   => [0,13,7,15,5,8],    # black, bright magenta, white,
                                      # bright white, magenta, bright black
    orangegrey => [1,0,8,7,11,9,15,3],# red, black, bright black, white, bright
                                      # yellow, bright red, bright white, yellow
  );
  }
}

sub get_kernel {
  open(my $fh, '<', '/proc/version') or warn($!);
  my $version = <$fh>;
  my ($kernel) = $version =~ /(2\.[0-9]\.[0-9\S]+)/;  
  return($kernel);
}

sub get_no_proc {
  opendir(my $dh, '/proc') or warn($!);
  my @processes = grep{/^[0-9]+/} readdir($dh); # PIDs
  return(scalar(@processes));
}

sub get_gtk_info {
  my $wanted = shift;
  if(!defined($wanted)) {
    $wanted = 'theme';
  }
  my ($gtk_theme,$gtk_font,$gtk_icons,$gtk_toolbar_style) = ('None found') x 4;
  if(-f "$ENV{HOME}/.gtkrc-2.0") {
    open(my $fh, '<', "$ENV{HOME}/.gtkrc-2.0") or warn($!);
    while(<$fh>) {
      if(/gtk-theme-name\s*=\s*"(.+)"/) {
        $gtk_theme = $1;
        print "GTK Theme: $gtk_theme\n" if($DEBUG);
      }
      if(/gtk-icon-theme-name\s*=\s*"(.+)"/) {
        $gtk_icons = $1;
        print "GTK Icons: $gtk_icons\n" if($DEBUG);
      }
      if(/gtk-font-name\s*=\s*"(.+)"/) {
        $gtk_font = $1;
        print "GTK Font: $gtk_font\n" if($DEBUG);
      }
      if(/gtk-toolbar-style\s*=\s*([0-9]+)/) {
        $gtk_toolbar_style = $1;
        print "GTK Toolbar Style: $gtk_toolbar_style\n" if($DEBUG);
      }
    }
  }
  return($gtk_theme)         if($wanted eq 'theme');
  return($gtk_icons)         if($wanted eq 'icons');
  return($gtk_font)          if($wanted eq 'font');
  return($gtk_toolbar_style) if($wanted eq 'toolbar');
  return(-1);
}

sub get_disk_total {
  my $wanted = shift;
  if(!defined($wanted)) {
    $wanted = 'size';
  }
  open(my $df, '-|', 'df -h --total') or warn($!);
  my($size,$used,$avail,$percent);
  while(<$df>) {
    if(/^total\s+([0-9.MGTP]+)\s+([0-9.MGTP]+)\s+([0-9.MGTP]+)\s+([0-9]+%)/) {
      ($size,$used,$avail,$percent) = ($1,$2,$3,$4);
    }
  }
  return($size)    if($wanted eq 'size');
  return($used)    if($wanted eq 'used');
  return($avail)   if($wanted eq 'avail');
  return($percent) if($wanted eq 'percent');
  return(-1);
}

sub get_mem {
  my $wanted = shift;
  if(!defined($wanted)) {
    $wanted = 'free';
  }
  open(my $fh, '<', '/proc/meminfo') or warn($!);
  my ($total,$free,$buffers,$cached) = undef;
  while(<$fh>) {
    if(/^MemTotal:\s+([0-9]+)\s+/) {
      $total = to_mb($1);
    }
    elsif(/^MemFree:\s+([0-9]+)\s+/) {
      $free = to_mb($1);
    }
    elsif(/^Buffers:\s+([0-9]+)\s+/) {
      $buffers = to_mb($1);
    }
    elsif(/^Cached:\s+([0-9]+)/) {
      $cached = to_mb($1);
    }
  }
  my $avail = $free + ($buffers + $cached);
  my $used  = $total - $avail;
  return($avail) if($wanted eq 'avail');
  return($used)  if($wanted eq 'used');
  return($total) if($wanted eq 'total');
}

sub to_mb {
  my $kb = shift;
  return(sprintf("%d",$kb/1024));
}

sub get_uptime {
  my $wanted = shift;
  if(!defined($wanted)) {
    $wanted = 'days';
  }
  chomp(my $uptime = `uptime`);
  #my $uptime = ' 20:27:42 up 14:52,  2 users,  load average: 0.07, 0.11';
  $uptime =~ s/.+ up //;

  my ($days,$mins) = split(/,/, $uptime, 3);
  if($days =~ /min/) { # no days
    $mins = $days;
    $days = 0;
  }

  #FIXME
  $days  =~ s/^\s+//;
  $days =~ s/\s+\S+//; # remove 'days'
  $mins  =~ s/^\s+//;  # really HH::MM

  if($days =~ /:/) { # no days
    $mins = $days;
    $days = 0;
  }
  return($days)  if($wanted eq 'days');
  return($mins)  if($wanted eq 'mins');
}

sub get_no_users {
  chomp(my @users = split(/ /, `users`));
  for(@users) {
    if($_ =~ m/$ENV{USER}/) {
      $_ = "\033[38;5;160m$_\033[0m";
    }
  }
  return(sprintf("%d (%s)", scalar(@users), join(', ', @users)));
}

sub get_shell {
  my $shell = $ENV{SHELL};
  return(-1) unless(defined($shell));
  $shell =~ s;.+/(.+)$;$1;;
  return($shell);
}

sub get_terminal { return($ENV{TERM}); }

sub get_cpu {
  chomp(my $cpu = `uname -p`);
  if(!defined($cpu) or($cpu eq 'unknown')) { # ARMs seems to be 'unknown'
    open(my $fh, '<', '/proc/cpuinfo') or die($!);
    my @cpuinfo = <$fh>;
    close($fh);

    for(@cpuinfo) {
      if(/^Processor\s+:\s+(.+)/) {
        $cpu = $1;
        last;
      }
    }
  }
  return($cpu);
}

sub print_out {
  my $color = $default_colorscheme;
  my $logo = $default_logo;

  open(my $fh, '<', $logo) or die($!);
  my @logo = <$fh>;
  close($fh);

  if(exists($colorschemes{$color})) {
    $color = $colorschemes{$color};
  }
  else {
    $color = $colorschemes{ansi};
  }

  @$color = shuffle(@$color) if($opt_random_colors);

  #FIXME
  my $f = join('', @logo);
  @logo = split(/\n/, $f);
  #FIXME

  return(\@logo);
}

sub colorme {
  my @foo = @_;
  my $f = join('', @foo);
  my @data = split(//, $f);
  my @toreturn;

  my $colorizer = undef;
  if(exists($colorschemes{$default_colorscheme})) {
    $colorizer = $colorschemes{$default_colorscheme};
  }
  else {
    $colorizer = $colorschemes{ansi};
  }

  @$colorizer = shuffle(@$colorizer) unless($opt_random_colors);

  my $i = 0;
  for(@data) {
    if($i == scalar(@$colorizer)-1) {
      $i = 0;
    }
    if($_ eq '') {
      push(@toreturn, $_);
    }
    else {
      push(@toreturn, "\e[38;5;@$colorizer[$i]" . 'm' . $_ . "\e[0m");
    }
    $i++;
  }
  return(@toreturn);
}

sub get_wm {
  my $active_wm = 'Unknown';
  my %wm_list = (
    Ratpoison     => 'ratpoison',
    StumpWM       => 'stumpwm',
    dwm           => 'dwm',
    wmii          => 'wmii',
    i3            => 'i3',
    Openbox       => 'openbox',
    Fluxbox       => 'fluxbox',
    Blackbox      => 'blackbox',
    FVWM          => 'fvwm',
    Enlightenment => 'enlightenment',
    IceWM         => 'icewm',
    PekWM         => 'pekwm',
    Musca         => 'musca',
    WindowMaker   => 'wmaker',
    Metacity      => 'metacity',
    Kwin          => 'kwin',
    Xfwm4         => 'xfwm4',
    Beryl         => 'beryl',
    Compiz        => 'compiz',
    Matchbox      => 'hildon-desktop',

  );
  my %rev_wm = reverse(%wm_list);

  # busybox ps will be $5
  open(my $ps, '-|', 'ps -A|awk {\'print $4\'}') or(warn($!)); # ugly
  chomp(my @processes = <$ps>);
  close($ps);

  for my $friendly_wm(keys(%wm_list)) {
    for my $process(@processes) {
      if($process eq $wm_list{$friendly_wm}) {
        print "Found WM: $process\n" if($DEBUG);
        $active_wm = $rev_wm{$process};
        last;
      }
    }
  }
  return($active_wm);
}

sub get_os {
  if(-e '/etc/arch-release') {
    return("GNU/Linux (Arch Linux)");
  }
  elsif($^O eq 'linux') {
    return("GNU/Linux"); # be nice
  }
  else {
    return("Unknown");
  }
}

sub available_colorschemes {
  print "$_\n" for(sort(keys(%colorschemes)));
  exit(0);
}

my $output = print_out($default_colorscheme, $default_logo);

my $long = longest(@$output);

@$output[0] = sprintf(
  "%-${long}s %12s: \e[1m\e[38;5;253m%s\e[0m", @$output[0], 'OS', ucfirst(get_os())
);
@$output[1] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[1], 'Kernel', get_kernel()
);
@$output[2] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[2], 'WM', ucfirst(get_wm())
);
@$output[3] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[3], 'Theme',
  ucfirst(get_gtk_info())
);
@$output[4] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[4], 'Icons',
  ucfirst(get_gtk_info('icons'))
);
@$output[5] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[5], 'Font', 
  ucfirst(get_gtk_info('font'))
);
@$output[6] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[6], 'Toolbar', 
  get_gtk_info('toolbar')
);
@$output[7] = sprintf(
  "%-${long}s %12s: \e[1m\e[38;5;202m%s\e[0m/%s (\e[38;5;196m%s\e[0m)", 
  @$output[7], 'Disk',
  get_disk_total('used'), get_disk_total('size'), get_disk_total('percent'),
);
@$output[8] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[8], 'Processes', get_no_proc(),
);
@$output[9] = sprintf(
  "%-${long}s %12s: \e[38;5;240m%s\e[0mM/\e[1m\e[38;5;240m%s\e[0mM used",
  @$output[9], 'Memory', get_mem('used'), get_mem('total'),
);
@$output[10] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m days and \e[1m%s\e[0m", @$output[10], 'Uptime',
  get_uptime('days'), get_uptime('mins'),
);
@$output[11] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[11], 'Users',
  get_no_users()
);
@$output[12] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[12], 'Shell',
  get_shell(),
);
@$output[13] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[13], 'Terminal',
  get_terminal(),
);
@$output[14] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[14], 'CPU',
  get_cpu,
);

my $hostname = sprintf(
  "%-${long}s \e[1m\e[38;5;208m%20s\e[0m", '', `hostname`
);

print $hostname;
for(@$output) {
  # Ugliest hack ever... FIXME
  # fsck, it works just fine. No one likes ws anyway
  if(/(.+)\s+([A-Za-z]+: .+)/) {
    print colorme($1), $2, "\n";
  }
  else {
    print colorme($_),"\n";
  }
}
if($opt_shot) {
  #FIXME - scrot, import...
  system('scrot') == 0 or(warn($!));
  exit(0);
}

=pod

=head1 NAME

  screenfo - screenshot information tool for nerds

=head1 SYNOPSIS

  screenfo [OPTION]...

=head1 DESCRIPTION

Everybody likes 'The monthly screenshot thread' where one is supposed to show
off their latest setup.

Nobody likes screenshots that look awesome, but where there's no information
at all available.

B<screenfo> outputs a load of system information, including the running window
manager, GTK theme, icons, fonts, shell, terminal emulator, and much more,
while taking the screenshot.

=head1 OPTIONS

  -c,   --color     specify colorscheme to use
  -l,   --list      list available colorschemes
  -a,   --ascii     specify ascii art to use
  -n,   --noran     dont randomize the colors
  -s    --shot      take screenshot

  -h,   --help      show help and exit
  -v,   --version   show version info and exit

=head1 ENVIRONMENT

The configuration file should be placed in either /etc/screenfo.conf or
$XDG_CONFIG_HOME/screenfo/screenfo.conf

=head1 REQUIREMENTS

Perl => 5.10

The String::Utils module, available in AUR and
<http://github.com/trapd00r/String-Utils>

Some standard UNIX tools

scrot for taking the actual screenshot

=head1 AUTHOR

Written by Magnus Woldrich

=head1 REPORTING BUGS

Report bugs to trapd00r\@trapd00r.se or use the issue tracker located at
<http://github.com/trapd00r/screenfo/issues>

screenfo homepage: <http://github.com/trapd00r/screenfo>

=head1 COPYRIGHT

Copyright (C) 2010 Magnus Woldrich

License: GPLv2

=head1 HISTORY

Lets quote the Arch Linux user B<dtw> from a post on the BBS, late 2006:

    OK, all the time in the screenshots thread we get "What gtk theme is that?",
    "What is that in the corner?", blah blah blah.
    Now, while we try to encourage people to post that with their screenie why
    don't we make a simple script that grabs info from from the gtkrc's, .xinitrc,
    etc, and outputs into a nice cowsay-like soundbite?

Couple days later, user B<rab> made the first Perl version simply named
'info.pl'. There were a lot of people in the community helping out,
making it better, bigger, more complicated and virtually unmaintainable since
absolutely no modularization or subroutines were used.

People realized this and started to make their own versions in Bash and Python.

My intent was to fork the original project, clean it up and make it 
maintainable, but that was no fun. Therefore, B<screenfo> was born.

=head1 THANKS

I'd like to thank the Archlinux community for being awesome, B<kittykatt> for
providing some ASCII art that I stole without asking, and B<slush-> for coming up
with this awesome name.

=head1 SEE ALSO

The original post: <https://bbs.archlinux.org/viewtopic.php?id=24208&p=10>

screenFetch: <http://github.com/KittyKatt/screenFetch>

archey: <http://github.com/djmelik/archey>

=cut


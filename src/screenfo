#!/usr/bin/perl
use strict;
use Data::Dumper;
use List::Util qw(shuffle);
use String::Utils qw(longest);
use Getopt::Long;
use Pod::Usage;

my $DEBUG = 0;

require("./screenfo.conf");
if($@) {
  warn($@);
}

# imported from configuration file
our($now_playing, $default_colorscheme, %colorschemes, $default_logo,
    $color_support);
our($opt_random_colors) = undef;


GetOptions(
  'ascii:s' => \$default_logo,
  'color:s' => \$default_colorscheme,
  'list'    => \&available_colorschemes,
  'norand'  => \$opt_random_colors,
  'help'    => sub { pod2usage(verbose => 1) and exit(0); },
);
$default_logo = "./ascii/$default_logo"; # FIXME


sub get_kernel {
  open(my $fh, '<', '/proc/version') or warn($!);
  my $version = <$fh>;
  my ($kernel) = $version =~ /(2\.[0-9]\.[0-9]+)/;
  return($kernel);
}

sub get_no_proc {
  opendir(my $dh, '/proc') or warn($!);
  my @processes = grep{/^[0-9]+/} readdir($dh); # PIDs
  return(scalar(@processes));
}

sub get_gtk_info {
  my $wanted = shift // 'theme';
  my ($gtk_theme, $gtk_font, $gtk_icons, $gtk_toolbar_style) = undef;
  if(-f "$ENV{HOME}/.gtkrc-2.0") {
    open(my $fh, '<', "$ENV{HOME}/.gtkrc-2.0") or warn($!);
    while(<$fh>) {
      if(/gtk-theme-name="(.+)"/) {
        $gtk_theme = $1;
        print "GTK Theme: $gtk_theme\n" if($DEBUG);
      }
      if(/gtk-icon-theme-name="(.+)"/) {
        $gtk_icons = $1;
        print "GTK Icons: $gtk_icons\n" if($DEBUG);
      }
      if(/gtk-font-name="(.+)"/) {
        $gtk_font = $1;
        print "GTK Font: $gtk_font\n" if($DEBUG);
      }
      if(/gtk-toolbar-style=([0-9]+)/) {
        $gtk_toolbar_style = $1;
        print "GTK Toolbar Style: $gtk_toolbar_style\n" if($DEBUG);
      }
    }
  }
  return($gtk_theme)         if($wanted eq 'theme');
  return($gtk_icons)         if($wanted eq 'icons');
  return($gtk_font)          if($wanted eq 'font');
  return($gtk_toolbar_style) if($wanted eq 'toolbar');
  return(-1);
}

sub get_disk_total {
  my $wanted = shift // 'size';
  open(my $df, '-|', 'df -h --total') or warn($!);
  my($size,$used,$avail,$percent);
  while(<$df>) {
    if(/^total\s+([0-9.MGTP]+)\s+([0-9.MGTP]+)\s+([0-9.MGTP]+)\s+([0-9]+%)/) {
      ($size,$used,$avail,$percent) = ($1,$2,$3,$4);
    }
  }
  return($size)    if($wanted eq 'size');
  return($used)    if($wanted eq 'used');
  return($avail)   if($wanted eq 'avail');
  return($percent) if($wanted eq 'percent');
  return(-1);
}

sub get_mem {
  my $wanted = shift // 'free';
  open(my $fh, '<', '/proc/meminfo') or warn($!);
  my ($total,$free,$buffers,$cached) = undef;
  while(<$fh>) {
    if(/^MemTotal:\s+([0-9]+)\s+/) {
      $total = to_mb($1);
    }
    elsif(/^MemFree:\s+([0-9]+)\s+/) {
      $free = to_mb($1);
    }
    elsif(/^Buffers:\s+([0-9]+)\s+/) {
      $buffers = to_mb($1);
    }
    elsif(/^Cached:\s+([0-9]+)/) {
      $cached = to_mb($1);
    }
  }
  my $avail = $free + ($buffers + $cached);
  my $used  = $total - $avail;
  return($avail) if($wanted eq 'avail');
  return($used)  if($wanted eq 'used');
  return($total) if($wanted eq 'total');
}

sub to_mb {
  my $kb = shift;
  return(sprintf("%d",$kb/1024));
}

sub get_uptime {
  my $wanted = shift // 'days';
  chomp(my $uptime = `uptime`);
  $uptime =~ s/.+ up //;

  my ($days,$mins,$users) = split(/,/, $uptime, 4);
  $days  =~ s/^\s+//;
  $mins  =~ s/^\s+//;
  $users =~ s/^\s+//;

  if($days =~ /min/) { # no days
    $mins = $days;
    $days = -1;
  }
  return($days)  if($wanted eq 'days');
  return($mins)  if($wanted eq 'mins');
}

sub get_no_users {
  chomp(my @users = split(/ /, `users`));
  return(scalar(@users));
}

sub get_shell    { return($ENV{SHELL}); }
sub get_terminal { return($ENV{TERM}); }

sub get_cpu {
  chomp(my $cpu = `uname -p`);
  return($cpu);
}

sub print_out {
  my $color = $default_colorscheme;
  my $logo = $default_logo;

  open(my $fh, '<', $logo) or die($!);
  my @logo = <$fh>;
  close($fh);

  if(exists($colorschemes{$color})) {
    $color = $colorschemes{$color};
  }
  else {
    $color = $colorschemes{ansi};
  }

  @$color = shuffle(@$color) if($opt_random_colors);

  #FIXME
  my $f = join('', @logo);
  @logo = split(/\n/, $f);
  #FIXME

  return(\@logo);
}

sub colorme {
  my @foo = @_;
  my $f = join('', @foo);
  my @data = split(//, $f);
  my @toreturn;

  my $colorizer = undef;
  if(exists($colorschemes{$default_colorscheme})) {
    $colorizer = $colorschemes{$default_colorscheme};
  }
  else {
    $colorizer = $colorschemes{ansi};
  }

  @$colorizer = shuffle(@$colorizer) unless($opt_random_colors);

  my $i = 0;
  for(@data) {
    if($i == scalar(@$colorizer)-1) {
      $i = 0;
    }
    if($_ eq '') {
      push(@toreturn, $_);
    }
    else {
      push(@toreturn, "\e[38;5;@$colorizer[$i]" . 'm' . $_ . "\e[0m");
    }
    $i++;
  }
  return(@toreturn);
}

sub get_wm { return('ratpoison'); }

sub get_os {
  if(-e '/etc/arch-release') {
    return("GNU/Linux (Arch Linux)");
  }
  elsif($^O eq 'linux') {
    return("GNU/Linux"); # be nice
  }
}

sub available_colorschemes {
  print "$_\n" for(sort(keys(%colorschemes)));
  exit(0);
}

my $output = print_out($default_colorscheme, $default_logo);

my $long = longest(@$output);

@$output[0] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[0], 'OS', ucfirst(get_os())
);
@$output[1] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[1], 'Kernel', get_kernel()
);
@$output[2] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[2], 'WM', ucfirst(get_wm())
);
@$output[3] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[3], 'Theme',
  ucfirst(get_gtk_info())
);
@$output[4] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[4], 'Icons',
  ucfirst(get_gtk_info('icons'))
);
@$output[5] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[5], 'Font', 
  ucfirst(get_gtk_info('font'))
);

=who_cares
@$output[6] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[6], 'Toolbar', 
  get_gtk_info('toolbar')
);
=cut

@$output[7] = sprintf(
  "%-${long}s %12s: \e[1m\e[38;5;106m%s\e[0m/%s (\e[38;5;196m%s\e[0m)", 
  @$output[7], 'Disk',
  get_disk_total('avail'), get_disk_total('size'), get_disk_total('percent'),
);

@$output[8] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m", @$output[8], 'Processes', get_no_proc(),
);

@$output[9] = sprintf(
  "%-${long}s %12s: \e[38;5;240m%s\e[0mM/\e[1m\e[38;5;240m%s\e[0mM used",
  @$output[9], 'Memory', get_mem('used'), get_mem('total'),
);

#FIXME
@$output[10] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m and \e[1m%s\e[0m", @$output[10], 'Uptime',
  get_uptime('days'), get_uptime('mins'),
);

@$output[11] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[11], 'Users',
  get_no_users()
);

@$output[12] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[12], 'Shell',
  get_shell(),
);

@$output[13] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[13], 'Terminal',
  get_terminal(),
);

@$output[14] = sprintf(
  "%-${long}s %12s: \e[1m%s\e[0m %s", @$output[14], 'CPU',
  get_cpu,
);

my $hostname = sprintf(
  "%-${long}s \e[1m\e[38;5;208m%20s\e[0m", '', `hostname`
);

print $hostname;
for(@$output) {
  # Ugliest hack ever... FIXME
  # fsck, it works just fine. No one likes ws anyway
  if(/(.+)\s+([A-Za-z]+: .+)/) {
    print colorme($1), $2, "\n";
  }
  else {
    print colorme($_),"\n";
  }
}

=pod

=head1 SYNOPSIS

  screenfo

=head1 OPTIONS

  -c,   --color     specify colorscheme to use
  -l,   --list      list available colorschemes
  -a,   --ascii     specify ascii art to use
  -n,   --noran     turn off randomizing of colors

  -h,   --help      show help and exit

=cut
# vim: set tw=0 nowrap: #FIXME
